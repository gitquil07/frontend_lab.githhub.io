<!DOCTYPE html>
<html>
    <head>
        <meta charset="UTF-8">
        <title></title>
        <link rel="stylesheet" type="text/css" href="main.css">
    </head>
    <body>
        <div id="sidebar">
            <ul class="column first">
                <li class="naming">Основы ООП</li>
                <li class="page"><a href="../first/main_content_page.html" style="text-decoration: none; color: #000000;">Инкапсуляция</a></li>
                <li class="page"><a href="../second/main_content_page.html" style="text-decoration: none; color: #000000;">Наследование</a></li>
                <li class="page"><a href="../third/main_content_page.html" style="text-decoration: none; color: #000000;">Полиморфизм</a></li>
            </ul>
            <ul class="column second">
                <li class="naming">Принципы SOLID</li>
                <li class="page" style="width: auto;"><a href="../forth/main_content_page.html" style="text-decoration: none; color: #000000;">Принцип единственной обязанности</a></li>
                <li class="page" style="width: auto;"><a href="../fifth/main_content_page.html" style="text-decoration: none; color: #000000;">Принцип открытости/закрытости</a></li>
                <li class="page" style="width: auto;"><a href="../sixth/main_content_page.html" style="text-decoration: none; color: #000000;">Принцип подстановки Лисков</a></li>
                <li class="page" style="width: auto;"><a href="../seventh/main_content_page.html" style="text-decoration: none; color: #000000;">Принцип разделения интерфейсов</a></li>
                <li class="page" style="width: auto;"><a href="../eighth/main_content_page.html" style="text-decoration: none; color: #000000;">Принцип инверсии зависимостей</a></li>
            </ul>
        </div>
        <div id="content">
            <p id="lesson" style="font-family: Arial, Helvetica, sans-serif; font-size: x-large; font-weight: bold; margin-top: 150px;">>Принцип подстановки Лисков</p>
            <p id="description" style="margin: 0px 50px 0px 50px; color: rgba(255, 255, 255, 0.8); font-family: 'Gill Sans', 'Gill Sans MT', Calibri, 'Trebuchet MS', sans-serif; font-size: 20px;">
                Принцип подстановки Лисков (Liskov Substitution Principle) представляет собой некоторое руководство по созданию иерархий наследования. Изначальное определение данного принципа, которое было дано Барбарой Лисков в 1988 году, выглядело следующим образом:
                <br>
                Если для каждого объекта o1 типа S существует объект o2 типа T, такой, что для любой программы P, определенной в терминах T, поведение P не изменяется при замене o2 на o1, то S является подтипом T.
То есть иными словами класс S может считаться подклассом T, если замена объектов T на объекты S не приведет к изменению работы программы.

В общем случае данный принцип можно сформулировать так:
                <br>
                Должна быть возможность вместо базового типа подставить любой его подтип.<br>

                Фактически принцип подстановки Лисков помогает четче сформулировать иерархию классов, определить функционал для базовых и производных классов и избежать возможных проблем при применении полиморфизма.
                
                Проблему, с который связан принцип Лисков, наглядно можно продемонстрировать на примере двух классов Прямоугольника и Квадрата. Пусть они будут выглядеть следующим образом:
                <br>
                ФКак правило, квадрат представляют как частный случай прямоугольника - те же прямые углы, 
                четыре стороны, 
                только ширина обязательно равна высоте. Поэтому в классе Квадрат у одного свойства устанавливаются сразу и ширина, и высота:
                <br>
                На первый взгляд вроде все правильно, классы предельно простые, всего два свойства, и, казалось бы, 
                сложно где-то ошибиться. Однако представим ситуацию, что в главной программе у нас следующий код:
                <br>
                <br>
                С точки зрения прямоугольника метод TestRectangleArea выглядит нормально, но не с точки зрения квадрата. 
                Мы ожидаем, что переданный в метод TestRectangleArea объект будет вести себя как стандартный прямоугольник. 
                Однако квадрат, будучи в иерархии наследования прямоугольником, все же ведет себя не как прямоугольник. В итоге программа вывалится в ошибку.
                <br>
                Иногда для выхода из подобных ситуаций прибегают к специальному хаку, который заключается в проверке объекта на соответствие типам:<br>
                Но такая проверка не отменяет того факта, что с архитектурой классов что-то не так. Более того такие решения только больше подчеркивают проблему несовершенства архитектуры. 
                И проблема заключается в том, что производный класс Square не ведет себя как базовый класс Rectangle, и поэтому его не следует наследовать от данного базового класса. 
                В этом и есть практический смысл принципа Лисков. 
                Производный класс, который может делать меньше, чем базовый, обычно нельзя подставить вместо базового, и поэтому он нарушает принцип подстановки Лисков.
                <br>
                Существует несколько типов правил, которые должны быть соблюдены для выполнения принципа подстановки Лисков. Прежде всего это правила контракта.

Контракт представляет собой некоторый интерфейс базового класса, некоторые соглашения по его использованию, которым должен следовать класс-наследник. Контракт задает ряд ограничений или правил, и производный класс должен выполнять эти правила:

Предусловия (Preconditions) не могут быть усилены в подклассе. Другими словами подклассы не должны создавать больше предусловий, чем это определено в базовом классе, для выполнения некоторого поведения

Предусловия представляют набор условий, необходимых для безошибочного выполнения метода. Например:
                <br>
                Здесь условное выражение служит предусловием - без его выполнения не будут выполняться остальные действия, а метод завершится с ошибкой.

Причем объектом предусловий могут быть только общедоступные свойства или поля класса или параметры метода, как в данном случае. Приватное поле не может быть объектом для предусловия, 
так как оно не может быть установлено из вызывающего кода. Например, в следующем случае условное выражение не является предусловием:
                <br>
                Теперь, допустим, есть два класса: Account (общий счет) и MicroAccount (мини-счет с ограничениями). И второй класс переопределяет метод SetCapital:
                <br>
                В этом случае подкласс MicroAccount добавляет дополнительное предусловие, то есть усиливает его, что недопустимо. Поэтому в реальной задаче мы можем столкнуться с проблемой:
                <br>
                С точки зрения класса Account метод InitializeAccount() вполне является работоспособным. Однако при передаче в него объекта MicroAccount мы столкнемся с ошибкой. В итоге пинцип Лисков будет нарушен.

Постусловия (Postconditions) не могут быть ослаблены в подклассе. То есть подклассы должны выполнять все постусловия, которые определены в базовом классе.

Постусловия проверяют состояние возвращаемого объекта на выходе из функции. Например:
                <br>
                Второе условное выражение здесь является постусловием.

Рассмотрим пример нарушения принципа Лисков при ослаблении постусловия:
                <br>
                В качестве постусловия в классе Account используется начисление бонусов в 100 единиц к финальной сумме, если начальная сумма от 1000 и более. В классе MicroAccount это условие не используется.

Теперь посмотрим, с какой проблемой мы можем столкнуться с данными классами:
                <br>
                Исходя из логики класса Account, в методе CalculateInterest мы ожидаем получить в качестве результата числа 1200. Однако логика класса MicroAccount показывает другой результат. В итоге мы приходим к нарушению принципа Лисков, хотя формально мы просто применили стандартные принципы ООП - полиморфизм и наследование.

Инварианты (Invariants) — все условия базового класса - также должны быть сохранены и в подклассе

Инварианты - это некоторые условия, которые остаются истинными на протяжении всей жизни объекта. Как правило, инварианты передают внутреннее состояние объекта. Например:
                <br>
                Поле age выступает инвариантом. И поскольку его установка возможна только через конструктор или свойство, то в любом случае выполнение предусловия и в конструкторе, и в свойстве гарантирует, что возраст не будет меньше 0. И данное объектоятельство сохранит свою истинность на протяжении всей жизни объекта User.

Теперь рассмотрим, как здесь может быть нарушен принцип Лисков. Пусть у нас будут следующие два класса:
                <br>
                С точки зрения класса Account поле не может быть меньше 100, и в обоих случаях, где идет присвоение - в конструкторе и свойстве это гарантируется. 
                А вот производный класс MicroAccount, переопределяя свойство Capital, этого уже не гарантирует. Поэтому инвариант класса Account нарушается.
                <br>
                Во всех трех вышеперечисленных случаях проблема решается в общем случае с помощью абстрагирования и выделения общего функционала, 
                который уже наследуют классы Account и MicroAccount. То есть не один из них наследуется от другого, а оба они наследуются от одного общего класса.

Таким образом, принцип подстановки Лисков заставляет задуматься над правильностью построения иерархий классов и применения полиморфизма, 
позволяя уйти от ложных иерархий наследования и делая всю систему классом более стройной и непротиворечивой.

            </p>
        </div>
        <div id="footer" style="height: 320px;">
            <ul class="socials" style="margin: 35px 150px 0px 200px; float: left;">
                <li style="height: 35px; color: rgba(255, 255, 255, 0.5); font-family: 'Franklin Gothic Medium', 'Arial Narrow', Arial, sans-serif; font-size: large;">OOPWB</li>
                <li>
                    <a href=""><img src="https://cdn1.iconfinder.com/data/icons/logotypes/32/youtube-512.png" width="30px" height="30px"></a><br>
                    <a href=""><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/a/a5/Instagram_icon.png/1024px-Instagram_icon.png" width="30px" height="30px"></a><br>
                    <a href=""><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/8/82/Telegram_logo.svg/1024px-Telegram_logo.svg.png" width="30px" height="30px"></a><br>
                    <a href=""><img src="https://image.flaticon.com/icons/png/512/2504/2504942.png" width="30px" height="30px"></a>
                </li>
            </ul>
            <ul class="middle" style="margin: 30px 30px 0px 0px;">
                <li style="height: 35px; color: rgba(255, 255, 255, 0.5); font-size: 15px;">Support</li>
                <li>Contact Us</li>
                <li>FAQ</li>
                <li>Downloads</li>
                <li>Locate A Dealer</li>
                <li>Product Registration</li>
                <li>Spare Parts</li>
            </ul>
            <ul class="middle">
                <li style="height: 35px; color: rgba(255, 255, 255, 0.5); font-size: 15px;">OOPWB</li>
                <li>About</li>
                <li>Design</li>
                <li>Careers</li>
                <li>NewsRoom</li>
                <li>Access</li>
            </ul>
            <ul class="e-mail" style="float: right; margin: 35px 200px 0px 0px;">
                <li><img src="https://icons-for-free.com/iconfiles/png/512/envenlope+letter+mail+icon-1320166581886181651.png" width="25px" height="25px"> <span>Stay up to date on the latest from OOPWB</span></li>
                <li>
                    <form>
                        <p>
                            <input type="email" placeholder="Enter your e-mail address">
                        </p>
                        <p>
                            <button id="sign_up_button" onclick="">Sign Up</button>
                        </p>
                    </form>
                </li>
            </ul>
        </div>
        <script>
            function SomeFunc(){
                var pages = document.getElementsByClassName("page");
                var lesson = document.getElementsById("lesson");
                for(let i = 0; i < pages.length; i++){
                    if(pages[i].innerHTML == lesson.innerHTML){
                        pages[i].clientWidth = "250px";
                    }
                }
            }    
        </script>
    </body>
</html>