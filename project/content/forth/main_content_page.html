<!DOCTYPE html>
<html>
    <head>
        <meta charset="UTF-8">
        <title></title>
        <link rel="stylesheet" type="text/css" href="main.css">
    </head>
    <body>
        <div id="sidebar">
            <ul class="column first">
                <li class="naming">Основы ООП</li>
                <li class="page"><a href="../first/main_content_page.html" style="text-decoration: none; color: #000000;">Инкапсуляция</a></li>
                <li class="page"><a href="../second/main_content_page.html" style="text-decoration: none; color: #000000;">Наследование</a></li>
                <li class="page"><a href="../third/main_content_page.html" style="text-decoration: none; color: #000000;">Полиморфизм</a></li>
            </ul>
            <ul class="column second">
                <li class="naming">Принципы SOLID</li>
                <li class="page" style="width: auto;"><a href="../forth/main_content_page.html" style="text-decoration: none; color: #000000;">Принцип единственной обязанности</a></li>
                <li class="page" style="width: auto;"><a href="../fifth/main_content_page.html" style="text-decoration: none; color: #000000;">Принцип открытости/закрытости</a></li>
                <li class="page" style="width: auto;"><a href="../sixth/main_content_page.html" style="text-decoration: none; color: #000000;">Принцип подстановки Лисков</a></li>
                <li class="page" style="width: auto;"><a href="../seventh/main_content_page.html" style="text-decoration: none; color: #000000;">Принцип разделения интерфейсов</a></li>
                <li class="page" style="width: auto;"><a href="../eighth/main_content_page.html" style="text-decoration: none; color: #000000;">Принцип инверсии зависимостей</a></li>
            </ul>
        </div>
        <div id="content">
            <p id="lesson" style="font-family: Arial, Helvetica, sans-serif; font-size: x-large; font-weight: bold; margin-top: 150px;">Принцип единственной обязанности</p>
            <p id="description" style="margin: 0px 50px 0px 50px; color: rgba(255, 255, 255, 0.8); font-family: 'Gill Sans', 'Gill Sans MT', Calibri, 'Trebuchet MS', sans-serif; font-size: 20px;">
                Термин "SOLID" представляет собой акроним для набора практик проектирования программного кода и построения гибкой и адаптивной программы. 
                Данный термин был введен 15 лет назад известным американским специалистом в области программирования Робертом Мартином (Robert Martin), 
                более известным как "дядюшка Боб" или Uncle Bob (Bob - сокращение от имени Robert).
                <br>
                Сам акроним образован по первым буквам названий SOLID-принципов:
                <br>
                Single Responsibility Principle (Принцип единственной обязанности)
                <br>
                Open/Closed Principle (Принцип открытости/закрытости)
                <br>
                Liskov Substitution Principle (Принцип подстановки Лисков)
                <br>
                Interface Segregation Principle (Принцип разделения интерфейсов)
                <br>
                Dependency Inversion Principle (Принцип инверсии зависимостей)
                <br>
                Принципы SOLID - это не паттерны, их нельзя назвать какими-то определенными догмами, которые надо обязательно применять при разработке, однако их использование позволит улучшить код программы, упростить возможные его изменения и поддержку.
                <br>
                Принцип единственной обязанности (Single Responsibility Principle) можно сформулировать так:

У класса должна быть только одна причина для изменения

Под обязанностью здесь понимается набор функций, которые выполняют единую задачу. Суть этого принципа заключается в том, что класс должен выполнять одну единственную задачу. Весь функционал класса должен быть целостным, обладать высокой связностью (high cohesion).

Конкретное применение принципа зависит от контекста. В данном случае важно понимать, как изменяется класс. Если класс выполняет несколько различных функций, и они изменяются по отдельности, то это как раз тот случай, когда можно применить принцип единственной обязанности. То есть иными словами, у класса несколько причин для изменения.

Но если же все функции класса, как правило, изменяются вместе и составляют одно функциональное целое, решают одну задачу, то нет смысла применять данный принцип. Рассмотрим применение принципа на примере.

Допустим, нам надо определить класс отчета, по которому мы можем перемещаться по страницам и который можно выводить на печать. На первый взгляд мы могли бы определить следующий класс:
                <br>
                Первые три метода относятся к навигации по отчету и представляют одно единое функциональное целое. От них отличается метод Print, 
                который производит печать. Что если нам понадобится печатать отчет на консоль или передать его на принтер для физической печати на бумаге? Или вывести в файл? 
                Сохранить в формате html, txt, rtf и т.д.? 
                Очевидно, что мы можем для этого поменять нужным образом метод Print(). Однако это вряд ли затронет остальные методы, которые относятся к навигации страницы.
                <br>
                Также верно и обратное - изменение методов постраничной навигации вряд ли повлияет на возможность вывода текста отчета на принтер или на консоль. Таким образом, у нас здесь прослеживаются две причины для изменения, значит, класс Report обладает двумя обязанностями, и от одной из них этот класс надо освободить.
                <br>
                Код и данные, составляющие вместе класс, называют членами. Данные, определяемые классом, называют полями, или переменными экземпляра. 
                А код, оперирующий данными, содержится в функциях-членах, самым типичным представителем которых является метод. 
                В C# метод служит в качестве аналога подпрограммы. (К числу других функций-членов относятся свойства, события и конструкторы.) 
                Таким образом, методы класса содержат код, воздействующий на поля, определяемые этим классом.
                В этом случае мы могли бы вынести функционал печати в отдельный класс, а потом применить агрегацию:
                <br>
                Теперь объект Report получает ссылку на объект IPrinter, который используется для печати, и через метод Print выводится содержимое отчета:
                <br>
                Побочным положительным действием является то, что теперь функционал печати инкапсулируется в одном месте, и мы сможем использовать его повторно для объектов других классов, а не только Report.

Однако обязанности в классах не всегда группируются по методам. Вполне возможно, что в одном методе сгруппировано несколько обязанностей. Например:
                <br>
                Класс имеет один единственный метод Process, однако этот небольшой метод, содержит в себе как минимум четыре обязанности: ввод данных, их валидация, создание объекта Phone и сохранение. В итоге класс знает абсолютно все: как получать данные, как валидировать, как сохранять. При необходимости в него можно было бы засунуть еще пару обязанностей. Такие классы еще называют "божественными" или "классы-боги", так как они инкапсулируют в себе абсолютно всю функциональность. Подобные классы являются одним из распространенных анти-паттернов, и их применения надо стараться избегать.

                Хотя тут довольно немного кода, однако при последующих изменениях метод Process может быть сильно раздут, а функционал усложнен и запутан.

                Теперь изменим код класса, инкапсулировав все обязанности в отдельных классах:
                <br>
                Возможное применение класса:
                <br>
                еперь для каждой обязанности определен свой интерфейс. Конкретные реализации обязанностей устнавливаются в виде интрефейсов в целевом классе.

                В то же время кода стало больше, в связи с чем программа усложнилась. 
                И, возможно, подобное усложнение может показаться неоправданным при наличии одного небольшого метода, который необязательно будет изменяться. Однако при модификации стало гораздо проще вводить новый функционал без изменения существующего кода. 
                А все части метода Process, будучи инкапсулированными во внешних классах, теперь не зависят друг от друга и могут изменяться самостоятельно.
                <br>Распространенные случаи нарушения принципа SRP<br>
                Нередко принцип единственной обязанности нарушает при смешивании в одном классе функциональности разных уровней. Например, класс производит вычисления и выводит их пользователю, то есть соединяет в себя бизнес-логику и работу с пользовательским интерфейсом. Либо класс управляет сохранением/получением данных и выполнением над ними вычислений, что также нежелательно. Класс слеует применять только для одной задачи - либо бизнес-логика, либо вычисления, либо работа с данными.
                
                Другой распространенный случай - наличие в классе или его методах абсолютно несвязанного между собой функционала.
            </p>
        </div>
        <div id="footer" style="height: 320px;">
            <ul class="socials" style="margin: 35px 150px 0px 200px; float: left;">
                <li style="height: 35px; color: rgba(255, 255, 255, 0.5); font-family: 'Franklin Gothic Medium', 'Arial Narrow', Arial, sans-serif; font-size: large;">OOPWB</li>
                <li>
                    <a href=""><img src="https://cdn1.iconfinder.com/data/icons/logotypes/32/youtube-512.png" width="30px" height="30px"></a><br>
                    <a href=""><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/a/a5/Instagram_icon.png/1024px-Instagram_icon.png" width="30px" height="30px"></a><br>
                    <a href=""><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/8/82/Telegram_logo.svg/1024px-Telegram_logo.svg.png" width="30px" height="30px"></a><br>
                    <a href=""><img src="https://image.flaticon.com/icons/png/512/2504/2504942.png" width="30px" height="30px"></a>
                </li>
            </ul>
            <ul class="middle" style="margin: 30px 30px 0px 0px;">
                <li style="height: 35px; color: rgba(255, 255, 255, 0.5); font-size: 15px;">Support</li>
                <li>Contact Us</li>
                <li>FAQ</li>
                <li>Downloads</li>
                <li>Locate A Dealer</li>
                <li>Product Registration</li>
                <li>Spare Parts</li>
            </ul>
            <ul class="middle">
                <li style="height: 35px; color: rgba(255, 255, 255, 0.5); font-size: 15px;">OOPWB</li>
                <li>About</li>
                <li>Design</li>
                <li>Careers</li>
                <li>NewsRoom</li>
                <li>Access</li>
            </ul>
            <ul class="e-mail" style="float: right; margin: 35px 200px 0px 0px;">
                <li><img src="https://icons-for-free.com/iconfiles/png/512/envenlope+letter+mail+icon-1320166581886181651.png" width="25px" height="25px"> <span>Stay up to date on the latest from OOPWB</span></li>
                <li>
                    <form>
                        <p>
                            <input type="email" placeholder="Enter your e-mail address">
                        </p>
                        <p>
                            <button id="sign_up_button" onclick="">Sign Up</button>
                        </p>
                    </form>
                </li>
            </ul>
        </div>
        <script>
            function SomeFunc(){
                var pages = document.getElementsByClassName("page");
                var lesson = document.getElementsById("lesson");
                for(let i = 0; i < pages.length; i++){
                    if(pages[i].innerHTML == lesson.innerHTML){
                        pages[i].clientWidth = "250px";
                    }
                }
            }    
        </script>
    </body>
</html>